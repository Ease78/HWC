---- DEBUG: DUMPING PARSE TREE ----
File with the following decls: 
  File_decl with these decls: 
    Part_decl: named 'simple_if', with stmts: 
      stmt: DECL:
        type:
          "bit"
        isPublic=1
        isSubpart=0
        isMemory=0
        name: control
      stmt: DECL:
        type:
          "bit"
        isPublic=1
        isSubpart=0
        isMemory=0
        name: in
      stmt: DECL:
        type:
          "bit"
        isPublic=1
        isSubpart=0
        isMemory=0
        name: out
      stmt: IF CHECK
        Expr: TWOOP of mode EQUALS with exprs
          LHand:
            Expr: IDENT, name = control
          RHand:
            Expr: NUM, value of 0
        stmt: CONNECTION, with left and right exprs:
          Expr: IDENT, name = out
          Expr: ARR, into array expr
            Expr: IDENT, name = in
           index of
            Expr: NUM, value of 0
  File_decl with these decls: 
    Part_decl: named 'main', with stmts: 
      stmt: DECL, that is private, is a subpart, and has the decl vars:
        Declaration: named 'a', with type (isMem=0)
          Expr: IDENT, name = simple_if
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = a
           accessing field 'in'
         index of
          Expr: NUM, value of 0
        Expr: NUM, value of 0
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = a
           accessing field 'in'
         index of
          Expr: NUM, value of 1
        Expr: NUM, value of 0
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = a
         accessing field 'control'
        Expr: NUM, value of 0
      stmt: ASSERTION
        Expr: TWOOP of mode EQUALS with exprs
          LHand:
            Expr: DOT, using expr
              Expr: IDENT, name = a
             accessing field 'out'
          RHand:
            Expr: NUM, value of 0
      stmt: DECL, that is private, is a subpart, and has the decl vars:
        Declaration: named 'b', with type (isMem=0)
          Expr: IDENT, name = simple_if
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = b
           accessing field 'in'
         index of
          Expr: NUM, value of 0
        Expr: NUM, value of 0
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = b
           accessing field 'in'
         index of
          Expr: NUM, value of 1
        Expr: NUM, value of 0
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = b
         accessing field 'control'
        Expr: NUM, value of 1
      stmt: ASSERTION
        Expr: TWOOP of mode EQUALS with exprs
          LHand:
            Expr: DOT, using expr
              Expr: IDENT, name = b
             accessing field 'out'
          RHand:
            Expr: NUM, value of 0
      stmt: DECL, that is private, is a subpart, and has the decl vars:
        Declaration: named 'c', with type (isMem=0)
          Expr: IDENT, name = simple_if
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = c
           accessing field 'in'
         index of
          Expr: NUM, value of 0
        Expr: NUM, value of 0
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = c
           accessing field 'in'
         index of
          Expr: NUM, value of 1
        Expr: NUM, value of 1
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = c
         accessing field 'control'
        Expr: NUM, value of 0
      stmt: ASSERTION
        Expr: TWOOP of mode EQUALS with exprs
          LHand:
            Expr: DOT, using expr
              Expr: IDENT, name = c
             accessing field 'out'
          RHand:
            Expr: NUM, value of 0
      stmt: DECL, that is private, is a subpart, and has the decl vars:
        Declaration: named 'd', with type (isMem=0)
          Expr: IDENT, name = simple_if
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = d
           accessing field 'in'
         index of
          Expr: NUM, value of 0
        Expr: NUM, value of 0
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = d
           accessing field 'in'
         index of
          Expr: NUM, value of 1
        Expr: NUM, value of 1
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = d
         accessing field 'control'
        Expr: NUM, value of 1
      stmt: ASSERTION
        Expr: TWOOP of mode EQUALS with exprs
          LHand:
            Expr: DOT, using expr
              Expr: IDENT, name = b
             accessing field 'out'
          RHand:
            Expr: NUM, value of 1
      stmt: DECL, that is private, is a subpart, and has the decl vars:
        Declaration: named 'e', with type (isMem=0)
          Expr: IDENT, name = simple_if
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = e
           accessing field 'in'
         index of
          Expr: NUM, value of 0
        Expr: NUM, value of 1
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = e
           accessing field 'in'
         index of
          Expr: NUM, value of 1
        Expr: NUM, value of 0
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = e
         accessing field 'control'
        Expr: NUM, value of 0
      stmt: ASSERTION
        Expr: TWOOP of mode EQUALS with exprs
          LHand:
            Expr: DOT, using expr
              Expr: IDENT, name = e
             accessing field 'out'
          RHand:
            Expr: NUM, value of 1
      stmt: DECL, that is private, is a subpart, and has the decl vars:
        Declaration: named 'f', with type (isMem=0)
          Expr: IDENT, name = simple_if
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = f
           accessing field 'in'
         index of
          Expr: NUM, value of 0
        Expr: NUM, value of 1
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = f
           accessing field 'in'
         index of
          Expr: NUM, value of 1
        Expr: NUM, value of 0
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = f
         accessing field 'control'
        Expr: NUM, value of 1
      stmt: ASSERTION
        Expr: TWOOP of mode EQUALS with exprs
          LHand:
            Expr: DOT, using expr
              Expr: IDENT, name = f
             accessing field 'out'
          RHand:
            Expr: NUM, value of 0
      stmt: DECL, that is private, is a subpart, and has the decl vars:
        Declaration: named 'g', with type (isMem=0)
          Expr: IDENT, name = simple_if
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = g
           accessing field 'in'
         index of
          Expr: NUM, value of 0
        Expr: NUM, value of 1
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = g
           accessing field 'in'
         index of
          Expr: NUM, value of 1
        Expr: NUM, value of 1
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = g
         accessing field 'control'
        Expr: NUM, value of 0
      stmt: ASSERTION
        Expr: TWOOP of mode EQUALS with exprs
          LHand:
            Expr: DOT, using expr
              Expr: IDENT, name = g
             accessing field 'out'
          RHand:
            Expr: NUM, value of 1
      stmt: DECL, that is private, is a subpart, and has the decl vars:
        Declaration: named 'h', with type (isMem=0)
          Expr: IDENT, name = simple_if
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = h
           accessing field 'in'
         index of
          Expr: NUM, value of 0
        Expr: NUM, value of 1
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: DOT, using expr
            Expr: IDENT, name = h
           accessing field 'in'
         index of
          Expr: NUM, value of 1
        Expr: NUM, value of 1
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = h
         accessing field 'control'
        Expr: NUM, value of 1
      stmt: ASSERTION
        Expr: TWOOP of mode EQUALS with exprs
          LHand:
            Expr: DOT, using expr
              Expr: IDENT, name = h
             accessing field 'out'
          RHand:
            Expr: NUM, value of 1

rc=0
