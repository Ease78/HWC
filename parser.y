/*
	A very rough parser for Hardware C
*/


/* Prologue C-statements */
%{
	#include <math.h>
	#include <stdio.h>
	#include <ctype.h>
	#include <string.h>
	#include <assert.h>

	#include "parsercommon.h"

	int yylex(void);
	void yyerror(char const *);
%}



/* these are the tokens which are not implicitly declared with "keyword"
 * down in the grammar below.
 */
%token NUM
%token IDENT

/* this generates the yytname[] table, used by tokenLookup() below */
%token-table

/* this declares the various types which can be stored in yylval. */
%union {
	char *str;
}



/* Grammar Rules */
%%


/* Parses  */

/* Add a line type instead */





/* Plan for empty parts */
part:
		"part" IDENT '{' part_stmts '}'
;

part_stmts:
		part_stmts part_stmt
	|	part_stmt
;

part_stmt:
		type IDENT ';'
;

type:
		"Data"
	|	"bit"
	|	type '[' NUM ']'
;


/*
stmt:
		%empty
	|	stmt line
;
line:
		'\n'
	|	expr '\n'	{ printf("   %g\n", $1); }
;
expr:
		NUM				{ $$ = $1; }
	|	expr expr '+'	{ $$ = $1 + $2; }
	|	expr expr '-'	{ $$ = $1 - $2; }
	|	expr expr '*'	{ $$ = $1 * $2; }
	|	expr expr '/'	{ $$ = $1 / $2; }
	|	expr expr '^'	{ $$ = pow($1, $2); }
	|	expr 'n'			{ $$ = -1 * $1; }
;
*/
%%


int main()
{
	return yyparse();
}

void yyerror(char const *s)
{
	fprintf(stderr, "%s\n", s);
}



/* this looks up a possible-IDENT in a table of strings generated by Bison; if
 * we find it, then we return the correct ID for that keyword.  But if we don't
 * find it, then strdup() the string to a new string, save it into yylval, and
 * then report an IDENT.
 *
 * Note that if assertFound==1, then we won't support the IDENT case at the
 * end.
 */
int tokenLookup(char *str, int assertFound)
{
	int i;
	int len = strlen(str);

	/* YYNTOKENS is the number of defined tokens in the table.  The table
	 * of strings is the array yytname[].
	 *
	 * Since we're always looking for double-quoted strings, the string
	 * at each entry that we care about will be
	 *       "keyword"
	 * or
	 *       "<="
	 *
	 * So, we'll perform several checks in a row:
	 *    - Is the first character of the string a double-quote?
	 *    - Is the string immediately after that, continuing for the
	 *      length of our target string, an exact match?
	 *    - After that, do we have another double-quote?
	 *    - After that, do we have a null terminator?
	 *
	 * If all of these checks pass, then the string in yytname[i] matches
	 * what we're lexing, so we look up the token ID in yytoknum[i] and
	 * return that.
	 *
	 * If we fail these checks for *ALL* of the tokens in the table, then
	 * this is an actual identifier (if allowed).
	 */
	for(i=0; i<YYNTOKENS; i++)
	{
		if(yytname[i] != NULL                   &&
		   yytname[i][0] == '"'                 &&
		   strncmp(yytname[i]+1, str, len) == 0 &&
		   yytname[i][len+1] == '"'             &&
		   yytname[i][len+2] == '\0')
		{
			return i;
		}
	}


	/* if we get here, then we failed the search.  Was that expected to
	 * be possible?
	 */
	if (assertFound)
	{
		assert(0);   // TODO
	}

	/* otherwise, save the string in the yylval, and we can return */
	yylval.str = strdup(str);
	return IDENT;
}

