
/*
	A very rough parser for Hardware C
*/


/* Prologue C-statements */
%{
	#include <math.h>
	#include <stdio.h>
	#include <ctype.h>
	#include <string.h>
	#include <assert.h>

	#include "parsercommon.h"
	#include "parse_tree/all.h"

	int yylex(void);
	void yyerror(char const *);


/* I don't have any need of this, but without it, Bison won't give me
 * access to yytoknum[].  (sigh).  -Russ
 */
#define YYPRINT(fp, yychar, yylval)   do {} while(0)
%}



/* these are the tokens which are not implicitly declared with "keyword"
 * down in the grammar below.
 */
%token<str> NUM
%token<str> IDENT

/* this generates the yytname[] table, used by tokenLookup() below */
%token-table



/* this declares the various types which can be stored in yylval. */
%union {
	char *str;

	Parser_File      *file;
	Parser_File_Decl *fileDecl;

	Parser_Part_Decl *partDecl;
	Parser_Part_Stmt *partStmt;

	Parser_Plugtype_Decl *plugtypeDecl;

	Parser_Type *type;
}

%type<file>     file
%type<fileDecl> file_decls
%type<fileDecl> file_decl

%type<partDecl> part_decl
%type<partStmt> opt_part_stmts
%type<partStmt> part_stmts
%type<partStmt> part_stmt

%type<plugtypeDecl> plugtype_decl

%type<type> type



/* Grammar Rules */
%%



file:
		%empty             { $$ = malloc(sizeof(Parser_File));
		                     $$->decls = NULL; }

	|	file_decls         { $$ = malloc(sizeof(Parser_File));
		                     $$->decls = $1; }
;

file_decls:
		           file_decl   { $$ = $1; }
	|	file_decls file_decl   { $$ = $2; $$->prev = $1; }
;

file_decl:
		part_decl        { $$ = malloc(sizeof(Parser_File_Decl));
		                   $$->partDecl = $1; }

	|	plugtype_decl    { $$ = malloc(sizeof(Parser_File_Decl));
		                   $$->plugtypeDecl = $1; }
;



part_decl:
		"part" IDENT '{' opt_part_stmts '}'
		                 { printf("User added a [part] with name [%s]\n", $2);
		                   $$ = malloc(sizeof(Parser_Part_Decl));
		                   $$->name  = $2;
		                   $$->stmts = $4; }
;

opt_part_stmts:
		%empty       { $$ = NULL; }
	|	part_stmts   { $$ = $1; }
;

part_stmts:
		           part_stmt   { $$ = $1; }
	|	part_stmts part_stmt   { $$ = $2; $$->prev = $1; }
;

part_stmt:
		type IDENT ';'   { printf("-Statement of type [-TODO-] with name [%s]\n", $2);
		                   $$ = malloc(sizeof(Parser_Part_Stmt));
		                   $$->type = $1;
			           $$->name = $2; }
;



plugtype_decl:
		"plugtype" IDENT '{' opt_plugtype_fields '}'
		                 { $$ = malloc(sizeof(Parser_Plugtype_Decl));
		                   /* TODO */ }
;

opt_plugtype_fields:
		%empty
	|	plugtype_fields
;

plugtype_fields:
		                plugtype_field
	|	plugtype_fields plugtype_field
;

plugtype_field:
		type IDENT opt_arrayDecls ';'
;


opt_arrayDecls:
		%empty
	|	arrayDecls
;

arrayDecls:
		           '[' expr ']'
	|	arrayDecls '[' expr ']'
;



type:
		"bit"              { $$ = malloc(sizeof(Parser_Type));
		                     $$->opt = TYPE_BIT; }

		// TODO: replace NUM with expr!
	|	type '[' NUM ']'   { printf("--Array of size [%s] declared\n", $3);
		                     $$ = malloc(sizeof(Parser_Type));
		                     $$->opt = TYPE_ARRAY;
		                     $$->base = $1;
		                     $$->len  = $3; }
;



expr:
	    /* TODO: add lots more! */
	  IDENT
;



%%

int main()
{
	return yyparse();
}

void yyerror(char const *s)
{
	fprintf(stderr, "%s\n", s);
}



/* this looks up a possible-IDENT in a table of strings generated by Bison; if
 * we find it, then we return the correct ID for that keyword.  But if we don't
 * find it, then strdup() the string to a new string, save it into yylval, and
 * then report an IDENT.
 *
 * Note that if assertFound==1, then we won't support the IDENT case at the
 * end.
 */
int tokenLookup(char *str, int assertFound)
{
	int i;
	int len = strlen(str);

	/* YYNTOKENS is the number of defined tokens in the table.  The table
	 * of strings is the array yytname[].
	 *
	 * Since we're always looking for double-quoted strings, the string
	 * at each entry that we care about will be
	 *       "keyword"
	 * or
	 *       "<="
	 *
	 * So, we'll perform several checks in a row:
	 *    - Is the first character of the string a double-quote?
	 *    - Is the string immediately after that, continuing for the
	 *      length of our target string, an exact match?
	 *    - After that, do we have another double-quote?
	 *    - After that, do we have a null terminator?
	 *
	 * If all of these checks pass, then the string in yytname[i] matches
	 * what we're lexing, so we look up the token ID in yytoknum[i] and
	 * return that.
	 *
	 * If we fail these checks for *ALL* of the tokens in the table, then
	 * this is an actual identifier (if allowed).
	 */
	for(i=0; i<YYNTOKENS; i++)
	{
		if(yytname[i] != NULL                   &&
		   yytname[i][0] == '"'                 &&
		   strncmp(yytname[i]+1, str, len) == 0 &&
		   yytname[i][len+1] == '"'             &&
		   yytname[i][len+2] == '\0')
		{
printf("tokenLookup(): str=\"%s\" returning %d\n", str, yytoknum[i]);

			return yytoknum[i];
		}
	}


	/* if we get here, then we failed the search.  Was that expected to
	 * be possible?
	 */
	if (assertFound)
	{
		assert(0);   // TODO
	}

printf("tokenLookup(): str=\"%s\" returning IDENT\n", str);
	/* otherwise, save the string in the yylval, and we can return */
	yylval.str = strdup(str);
	return IDENT;
}

