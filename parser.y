
/*
	A very rough parser for Hardware C
*/


/* Prologue C-statements */
%{
	#include <math.h>
	#include <stdio.h>
	#include <ctype.h>
	#include <string.h>
	#include <assert.h>

	#include "parsercommon.h"

	int yylex(void);
	void yyerror(char const *);


/* I don't have any need of this, but without it, Bison won't give me
 * access to yytoknum[].  (sigh).  -Russ
 */
#define YYPRINT(fp, yychar, yylval)   do {} while(0)
%}



/* these are the tokens which are not implicitly declared with "keyword"
 * down in the grammar below.
 */
%token<str> NUM
%token<str> IDENT

/* this generates the yytname[] table, used by tokenLookup() below */
%token-table

/* this declares the various types which can be stored in yylval. */
%union {
	char *str;
}



/* Grammar Rules */
%%



file:
		     file_decl
	|	file file_decl
;
file_decl:
		part_decl
	|	plugtype_decl
;



part_decl:
		"part" IDENT '{' opt_part_stmts '}'		{ printf("User added a [part] with name [%s]\n", $2); }
;

opt_part_stmts:
		%empty
	|	part_stmts
;

part_stmts:
		part_stmts part_stmt
	|	part_stmt
;

part_stmt:
		type IDENT ';'							{ printf("-Statement of type [-TODO-] with name [%s]\n", $2); }
;

type:
		"bit"
	|	type '[' NUM ']'						{ printf("--Array of size [%s] declared\n", $3); }
;



plugtype_decl:
		"plugtype" IDENT '{' opt_plugtype_fields '}'
;

opt_plugtype_fields:
		%empty
	|	plugtype_fields
;

plugtype_fields:
		                plugtype_field
	|	plugtype_fields plugtype_field
;

plugtype_field:
		type IDENT opt_arrayDecls ';'
;


opt_arrayDecls:
		%empty
	|	arrayDecls
;

arrayDecls:
		           '[' expr ']'
	|	arrayDecls '[' expr ']'
;



expr:
	    /* TODO: add lots more! */
	  IDENT
;



%%

int main()
{
	return yyparse();
}

void yyerror(char const *s)
{
	fprintf(stderr, "%s\n", s);
}



/* this looks up a possible-IDENT in a table of strings generated by Bison; if
 * we find it, then we return the correct ID for that keyword.  But if we don't
 * find it, then strdup() the string to a new string, save it into yylval, and
 * then report an IDENT.
 *
 * Note that if assertFound==1, then we won't support the IDENT case at the
 * end.
 */
int tokenLookup(char *str, int assertFound)
{
	int i;
	int len = strlen(str);

	/* YYNTOKENS is the number of defined tokens in the table.  The table
	 * of strings is the array yytname[].
	 *
	 * Since we're always looking for double-quoted strings, the string
	 * at each entry that we care about will be
	 *       "keyword"
	 * or
	 *       "<="
	 *
	 * So, we'll perform several checks in a row:
	 *    - Is the first character of the string a double-quote?
	 *    - Is the string immediately after that, continuing for the
	 *      length of our target string, an exact match?
	 *    - After that, do we have another double-quote?
	 *    - After that, do we have a null terminator?
	 *
	 * If all of these checks pass, then the string in yytname[i] matches
	 * what we're lexing, so we look up the token ID in yytoknum[i] and
	 * return that.
	 *
	 * If we fail these checks for *ALL* of the tokens in the table, then
	 * this is an actual identifier (if allowed).
	 */
	for(i=0; i<YYNTOKENS; i++)
	{
		if(yytname[i] != NULL                   &&
		   yytname[i][0] == '"'                 &&
		   strncmp(yytname[i]+1, str, len) == 0 &&
		   yytname[i][len+1] == '"'             &&
		   yytname[i][len+2] == '\0')
		{
printf("tokenLookup(): str=\"%s\" returning %d\n", str, yytoknum[i]);

			return yytoknum[i];
		}
	}


	/* if we get here, then we failed the search.  Was that expected to
	 * be possible?
	 */
	if (assertFound)
	{
		assert(0);   // TODO
	}

printf("tokenLookup(): str=\"%s\" returning IDENT\n", str);
	/* otherwise, save the string in the yylval, and we can return */
	yylval.str = strdup(str);
	return IDENT;
}

