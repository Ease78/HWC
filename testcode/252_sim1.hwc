part Sim1_AND
{
	public bit a,b;
	public bit out;

	out = a & b;
}

part Sim1_OR
{
	public bit a,b;
	public bit out;

	out = a | b;
}

part Sim1_NOT
{
	public bit in;
	public bit out;

	out = !in;
}

part Sim1_XOR
{
	public bit a,b;
	public bit out;

	out = a & ~b | ~a & b;
}

part Sim1_ADD
{
	public bit[32] a,b;    // Note: a[32],b[32] is ILLEGAL SYNTAX
	public bit[32] sum;
	public bit     carryOut;
	public bit     overflow;

	private bit[32] carryIns;
	carryIn[0] = 0;

	for (i; 0..32)
	{
		sum[i] = a[i] ^ b[i] ^ carryIn[i];

		// static if() is required here, because otherwise the
		// array indexing is out of bounds
		private bit curCarry = a[i] & b[i] | a[i] & carryIn[i] | b[i] & carryIn[i];
		static if (i < 32)
			carryIn[i+1] = curCarry;
		else
			carryOut     = curCarry;
	}

	overflow = (a[31] == b[31]) & (sum[31] != a[31]);
}

part Sim1_2sComplement
{
	public bit[32] in;
	public bit[32] out;

	subcomponent Sim1_ADD adder;
	adder.a = in;
	adder.b = 1;
	out = adder.out;
}

part Sim1_SUB
{
	public bit[32] a,b;
	public bit[32] out;

	subcomponent Sim1_ADD          adder;
	subcomponent Sim1_2sComplement comp;

	adder.a = a;

	comp.in = b;
	adder.b = comp.out;

	out = adder.sum;
}

