%{
#include <string.h>

#include "parsercommon.h"      // our own code, written by hand
#include "pt/all.h"    // our own code, written by hand

#include "parser.tab.h"        // auto-generated by Bison

int lineNum = 1;

int yydebug = 1;

%}


  /* disable some lex features that we don't need (for now) */
%option noyywrap
%option nounput
%option noinput



  /* This declares a special lexer state, which can control what sorts of rules
   * apply.  Normally, we only match rules which are *NOT* in any special state,
   * such as the EOF or \n rules just below.
   *
   * But, if (while we're in the normal state) we see the *BEGINNING* of a slash-star
   * comment, then we use the BEGIN() macro to turn on the special state.  From
   * then on, the *ONLY* rules which apply are the ones marked with that state
   * at the beginning of the line.
   *
   * Of course, we have a rule, which applies while in that special state, which
   * will return us to normal lexing.
   *
   * We could, of course, build a nasty regex to do all of this matching for us,
   * but this is a lot easier to read.  Plus, it lets us keep the 'lineNum'
   * variable up to date!
   */
%x IN_COMMENT


%%


  /* NOTE: Start comments with a little indentation, so that flex doesn't see
   *       slash-star as a matching rule.
   */

  /* TRIVIAL MATCHES
   *
   * If we hit EOF, terminate the parse; if we hit a newline, incremente lineNum
   * but do nothing else; if we hit any *other* whitespace, then simply swallow
   * it, one character at a time.
   */
<<EOF>>			return 0;
\n			lineNum++;
[ \t\r]			/* no action */



  /* BLOCK COMMENTS
   *
   * Handle the case where we enter the block.  Handle the case where we leave
   * the block.  Count newlines inside of blocks.  But then, treat any *other*
   * character as comments to ignore - ignoring them one at a time.
   */
[/]"*"			BEGIN(IN_COMMENT);
<IN_COMMENT>"*"+[/]	BEGIN(0);  /* end of comment */
<IN_COMMENT>\n		lineNum++;
<IN_COMMENT>.			/* no action */

  /* C++ LINE COMMENTS
   *
   * When you see the start of the comment, consume the entire line *EXCEPT*
   * for the newline at the end.  (This allows the newline rule above to kick
   * in, immediately after this.)
   */
[/][/][^\n]*			/* no action */



  /* IDENTIFIERS AND KEYWORDS
   *
   * This matches all identifiers (begin with underscore or letter, continue
   * with underscores, letters, and digits); it also matches all keywords,
   * since all keywords look like identifiers.
   *
   * To figure out how to interpret each possible-identifier that we see, we
   * must compare it to the table of strings generated by bison; if we
   * find a match, then we will return the assigned token ID for this keyword.
   * However, if we do *NOT* find a match, then the word will be copied to a
   * malloc() buffer, the pointer will be saved to yylval, and this function
   * will return IDENT.
   *
   * TODO: This rule will tolerate an "identifier" made up entirely of
   *       underscores - including a single!  Is this by design???
   */
[_a-zA-Z][_a-zA-Z0-9]*		return tokenLookup(yytext, 0);



  /* NUMERIC CONSTANTS
   *
   * Matches decimal or hexdecimal constants.  Underscores are allowed anywhere,
   * and ignored.
   *
   * Negative constants are not allowed; we interpret -NUM as unary negation.
   *
   * Note that we duplicate the string and save it, and then return the token
   * type.  We save it as a string, instead of converting to an integer, because
   * I'm lazy (for now).  But in the future, there are some good reasons to keep
   * this design, including:
   *    - The ability to continue to "pretty print" this constant in debug
   *      statements, exactly as it was coded.
   *    - The ability to support bigint.
   *
   * TODO: If we forbid all-underscores in the possibly-IDENT rule above, then
   *       we have to do the same here.
   */
[_1-9][_0-9]*		yylval.str = strdup(yytext); return NUM;
0x[_0-9a-fA-F]+		yylval.str = strdup(yytext); return NUM;



  /* OPERATORS
   *
   * This lists all of the operators in the language.  We start with the
   * longest ones, since if there are multiple interpretations we always want
   * the longest option.  (For instance, << should be interpteted as left
   * shift, *NOT* two less-thans.)
   *
   * The multi-character operators have to be looked up in the table of strings
   * generated by bison; they must always hit.  Note that we use the same
   * lookup function as we used for possible-identifiers, but we change the
   * second parameter: this parameter means "assert that this is in the token
   * table!"  So returning IDENT is never possible in these cases.
   *
   * When we get to the single-character operators, we simply return yytext[0]
   * because the defined token ID for any single-character token is the ASCII
   * code of that character.
   */
(<<|>>)				return tokenLookup(yytext, 1);
(&&|[|][|])			return tokenLookup(yytext, 1);
(==|!=|<=|>=)			return tokenLookup(yytext, 1);

[(){}\[\]]			return yytext[0];
[+\-*/%]			return yytext[0];
[=]				return yytext[0];
;				return yytext[0];


  /* LEXER ERROR, the default case */
.				printf("LEXER ERROR: %d='%c' at line %d.\n",yytext[0],yytext[0],lineNum); while(!feof(yyin)) putchar(getc(yyin));

